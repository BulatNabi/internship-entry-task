# Проект "Крестики-нолики" (TestTaskModulBank)

Этот проект представляет собой Web API для игры в "Крестики-нолики" (Tic-Tac-Toe), разработанный на ASP.NET Core. API позволяет создавать новые игры, делать ходы и получать информацию о состоянии игры.

## Содержание

1.  [Введение](#введение)
2.  [Архитектурные решения](#архитектурные-решения)
   * [Слоистая архитектура](#слоистая-архитектура)
   * [Разделение ответственности](#разделение-ответственности)
   * [Работа с игровым полем](#работа-с-игровым-полем)
   * [Идемпотентность ходов](#идемпотентность-ходов)
   * [Работа с ETag](#работа-с-etag)
   * [Обработка ошибок](#обработка-ошибок)
3.  [API Эндпоинты](#api-эндпоинты)
   * [Создание новой игры](#создание-новой-игры)
   * [Получение состояния игры](#получение-состояния-игры)
   * [Выполнение хода](#выполнение-хода)
4.  [Модели данных (DTOs)](#модели-данных-dtos)
   * [`GameDto`](#gamedto)
   * [`CreateGameRequestDto`](#creategamerequestdto)
   * [`MakeMoveRequestDto`](#makemoverequestdto)
   * [`PlayerSymbol`](#playersymbol)
   * [`GameStatus`](#gamestatus)
5.  [Настройка и запуск](#настройка-и-запуск)
   * [Предварительные требования](#предварительные-требования)
   * [Локальный запуск (без Docker)](#локальный-запуск-без-docker)
   * [Запуск с Docker Compose](#запуск-с-docker-compose)
6.  [Тестирование](#тестирование)
   * [Юнит-тесты](#юнит-тесты)
   * [Интеграционные тесты](#интеграционные-тесты)
7.  [Автор](#автор)

---

### Введение

Данный проект реализует бэкенд для классической игры в "Крестики-нолики". Он предоставляет RESTful API для взаимодействия с игрой. Ключевые особенности включают:

* Создание игры с настраиваемым размером поля.
* Отслеживание текущего состояния игры (в процессе, завершена, ничья).
* Валидацию ходов.
* Определение победителя или ничьей.
* Опциональный автоматический ход компьютера (реализовано в сервисе, но не явно выставлено в контроллере как опция запроса).

### Архитектурные решения

Проект построен с учетом современных принципов разработки и лучших практик для ASP.NET Core приложений.

#### Слоистая архитектура

Проект организован в виде слоистой архитектуры, несмотря на то, что все классы находятся в одной сборке. Это способствует четкому разделению ответственности и модульности:

* **Controllers:** Отвечают за обработку HTTP-запросов и ответов. Они являются тонким слоем, который делегирует бизнес-логику сервисам и преобразует DTO.
* **Services (Бизнес-логика):** Содержат основную бизнес-логику игры (создание, выполнение ходов, проверка выигрышных условий, определение ничьей). Они взаимодействуют с репозиториями.
* **Repositories (Слой доступа к данным):** Отвечают за взаимодействие с базой данных (CRUD-операции для `Game`). Используется Entity Framework Core.
* **Models:** POCO-классы, представляющие сущности базы данных (`Game`).
* **DTOs:** Объекты передачи данных, используемые для взаимодействия между API и клиентом, обеспечивающие четкое определение контрактов.
* **Enums:** Перечисления для статусов игры и символов игроков.
* **Interfaces:** Определяют контракты для сервисов и репозиториев, что облегчает тестирование и поддержку принципа инверсии зависимостей.
* **Converters:** Содержит специализированные конвертеры для сериализации/десериализации сложных типов (например, игрового поля).

#### Разделение ответственности

Каждый компонент выполняет строго определенный набор задач:

* **`GamesController`**: Принимает запросы, выполняет базовую валидацию входящих DTO, вызывает методы `IGameService` и возвращает `GameDto` или соответствующие HTTP-статусы.
* **`GameService`**: Содержит всю игровую логику: инициализация поля, проверка валидности хода, обновление состояния поля, определение победителя/ничьей, переключение хода. Взаимодействует с `IGameRepository`.
* **`GameRepository`**: Ответственен за сохранение и извлечение объектов `Game` из базы данных.

#### Работа с игровым полем

Игровое поле (`Board`) не хранится напрямую в базе данных как многомерный массив. Вместо этого, оно сериализуется в JSON-строку и хранится в свойстве `Game.BoardJson`. Это решение позволяет:

* **Гибкость:** Хранить произвольные размеры поля без необходимости адаптации схемы БД.
* **Оптимизация БД:** База данных хранит простую строку, а десериализация происходит в приложении только при необходимости.
* **Конвертер:** Для удобства работы с `BoardJson` разработан пользовательский `PlayerSymbolArrayConverter`, который позволяет `System.Text.Json` сериализовать и десериализовать `PlayerSymbol[,]` напрямую в JSON-строку и обратно.

#### Идемпотентность ходов

Эндпоинт `POST /api/games/{id}/move` разработан с учетом идемпотентности. Если клиент повторно отправляет запрос на уже сделанный ход (например, в ту же занятую ячейку тем же игроком, чей символ уже стоит), API вернет текущее состояние игры (статус `200 OK`) без повторного выполнения бизнес-логики сервиса. Это предотвращает непредвиденные побочные эффекты от повторных запросов.

#### Работа с ETag

Эндпоинт `GET /api/games/{id}` поддерживает кэширование с помощью заголовка `ETag`. При первом запросе API возвращает заголовок `ETag` на основе `LastUpdated` timestamp игры. При последующих запросах с `If-None-Match: <ETag>`, если игра не изменилась, API возвращает статус `304 Not Modified`, что сокращает объем передаваемых данных и нагрузку на сервер.

#### Обработка ошибок

API использует `ProblemDetails` (RFC 7807) для стандартизированной обработки ошибок. Это обеспечивает согласованный формат ответов об ошибках, что упрощает их обработку на стороне клиента. Типичные ошибки, возвращаемые API:

* `400 Bad Request` (если входные данные невалидны или ход невозможен).
* `404 Not Found` (если игра с указанным ID не найдена).

### API Эндпоинты

Базовый URL: `http://localhost:80/api/` (при запуске через Docker Compose)

#### Создание новой игры

* **URL:** `POST /api/games`
* **Описание:** Создает новую игру в "Крестики-нолики" с указанным размером поля.
* **Запрос (Request Body):** `application/json`
    ```json
    {
      "boardSize": 3
    }
    ```
* **Ответ (Success 201 Created):** `application/json`
    ```json
    {
      "id": "guid",
      "board": [
        ["None", "None", "None"],
        ["None", "None", "None"],
        ["None", "None", "None"]
      ],
      "boardSize": 3,
      "status": "InProgress",
      "currentTurn": "X",
      "movesCount": 0,
      "winner": null
    }
    ```
* **Ответ (Error 400 Bad Request):** `application/problem+json`
    ```json
    {
      "type": "[https://tools.ietf.org/html/rfc7807](https://tools.ietf.org/html/rfc7807)",
      "title": "One or more validation errors occurred.",
      "status": 400,
      "errors": {
        "BoardSize": [
          "The BoardSize field must be between 3 and 10."
        ]
      }
    }
    ```

#### Получение состояния игры

* **URL:** `GET /api/games/{id}`
* **Описание:** Возвращает текущее состояние игры по её ID.
* **Параметры пути:**
   * `id` (GUID): Уникальный идентификатор игры.
* **Заголовки запроса (опционально):**
   * `If-None-Match`: ETag, полученный ранее.
* **Ответ (Success 200 OK):** `application/json`
    ```json
    {
      "id": "guid",
      "board": [
        ["X", "None", "None"],
        ["None", "O", "None"],
        ["None", "None", "None"]
      ],
      "boardSize": 3,
      "status": "InProgress",
      "currentTurn": "X",
      "movesCount": 2,
      "winner": null
    }
    ```
  (включает заголовок `ETag`)
* **Ответ (Success 304 Not Modified):** Если `If-None-Match` совпадает и игра не изменилась.
* **Ответ (Error 404 Not Found):** `application/problem+json`
    ```json
    {
      "type": "[https://tools.ietf.org/html/rfc7807](https://tools.ietf.org/html/rfc7807)",
      "title": "Game Not Found",
      "status": 404,
      "detail": "Game with ID {id} not found."
    }
    ```

#### Выполнение хода

* **URL:** `POST /api/games/{id}/move`
* **Описание:** Выполняет ход в указанной игре.
* **Параметры пути:**
   * `id` (GUID): Уникальный идентификатор игры.
* **Запрос (Request Body):** `application/json`
    ```json
    {
      "gameId": "guid",
      "row": 0,
      "column": 0,
      "playerSymbol": "X"
    }
    ```
* **Ответ (Success 200 OK):** `application/json` (обновленное состояние игры)
    ```json
    {
      "id": "guid",
      "board": [
        ["X", "None", "None"],
        ["None", "O", "None"],
        ["None", "None", "None"]
      ],
      "boardSize": 3,
      "status": "InProgress",
      "currentTurn": "O",
      "movesCount": 1,
      "winner": null
    }
    ```
* **Ответ (Error 400 Bad Request):** `application/problem+json` (если ход невалиден)
    ```json
    {
      "type": "[https://tools.ietf.org/html/rfc7807](https://tools.ietf.org/html/rfc7807)",
      "title": "Move Validation Error",
      "status": 400,
      "detail": "Cell is already occupied."
    }
    ```
  или
    ```json
    {
      "type": "[https://tools.ietf.org/html/rfc7807](https://tools.ietf.org/html/rfc7807)",
      "title": "Move Validation Error",
      "status": 400,
      "detail": "It's not X's turn."
    }
    ```
  или
    ```json
    {
      "type": "[https://tools.ietf.org/html/rfc7807](https://tools.ietf.org/html/rfc7807)",
      "title": "Move Validation Error",
      "status": 400,
      "detail": "Game is already finished or drawn."
    }
    ```
* **Ответ (Error 404 Not Found):** `application/problem+json`
    ```json
    {
      "type": "[https://tools.ietf.org/html/rfc7807](https://tools.ietf.org/html/rfc7807)",
      "title": "Game Not Found",
      "status": 404,
      "detail": "Game with ID {id} not found."
    }
    ```

### Модели данных (DTOs)

#### `GameDto`

Представляет полное состояние игры, возвращаемое API.

```csharp
public class GameDto
{
    public Guid Id { get; set; }
    public PlayerSymbol[,] Board { get; set; } // Десериализованное поле
    public int BoardSize { get; set; }
    public GameStatus Status { get; set; }
    public PlayerSymbol CurrentTurn { get; set; }
    public int MovesCount { get; set; }
    public PlayerSymbol? Winner { get; set; } // X или O, или null если ничья/в процессе
}